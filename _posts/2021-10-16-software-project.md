---
layout: post
title: 软件工程导论重点
date: 2021-10-16
categories: blog
tags: [技术]
description: 关于软件工程的考点整理
---
# 第一章 软件工程学概述
## 软件特点
1、软件是计算机系统中的逻辑部件而不是物理部件，其显著特点是缺乏可见性。因此管理和控制软件开发过程相当困难。此外，软件维护通常意味着改正或修正原有的设计，从而使得软件较难维护。<br />2、软件的另一个特点就是规模庞大，程序的复杂性将随着程序规模的增加以指数型速度上升。
## 软件危机定义
软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。
### 两方面问题
软件危机包含下述两方面的问题：如何开发软件，以满足对软件日益增长的需求；如何维护数量不断膨胀的已有软件。
### 产生原因
一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。<br />**客观**：①软件不同于硬件，它是计算机系统中的逻辑部件而不是物理部件。由于软件缺乏“可见性”，管理和控制软件开发过程相当困难。<br />②软件的一个显著特点是规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升。<br />**主观**：计算机系统发展的早期阶段软件开发的个体化特点，忽视软件需求分析的重要性，认为软件开发就是写程序并设法使之运行，轻视软件维护，忽视评审，忽视测试等，引入一个变动要对所有已完成的配置成分都做相应的修改，不仅工作量大，而且逻辑上也更复杂，因此付出的代价剧增。
### 典型表现
（1）对软件开发成本和进度的估计常常很不准确。<br />（2）用户对“已完成的”软件系统不满意的现象经常发生。<br />（3）软件产品的质量往往靠不住。<br />（4）软件常常是不可维护的。<br />（5）软件通常没有适当的文档资料。<br />（6）软件成本在计算机系统总成本中所占的比例逐年上升。<br />（7）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。<br />​<br />
### 消除途径
1、应该树立对计算机软件的正确认识。认识到软件是程序、数据及文档的完整集合。（软件定义）<br />2、为了解决软件危机，既要有技术措施（方法和工具），又要有必要的组织管理措施。<br />3、充分认识软件开发是组织良好、管理严密、各类人员协同配合、共同完成的工程项目。（工程定义）<br />4、推广使用在实践中总结出来的开发软件的成功的技术和方法。<br />5、应该积极开发和使用计算机辅助软件工程（CASE）工具。
## 软件工程定义（背诵两种定义）
1、软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。<br />2、软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。”
### 本质特征（未考过，背）

1. 软件工程关注于大型程序的构造
1. 软件工程的中心课题是控制复杂性
1. 软件经常变化
1. 开发软件的效率非常重要
1. 和谐地合作是开发软件的关键
1. 软件必须有效地支持它的用户
1. 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品

​<br />
### 基本原理

1. 用分阶段的生命周期计划严格管理
1. 坚持进行阶段评审
1. 实行严格的产品控制
1. 采用现代程序设计技术
1. 结果应能清楚地审查
1. 开发小组的人员应该少而精
1. 承认不断改进软件工程实践的必要性
## 方法学三要素(知道）
3个要素：方法、工具和过程。

- 方法是完成软件开发的各项任务的技术方法，回答“怎样做"的问题；
- 工具是为运用方法而提供的自动的或半自动的软件工程支撑环境；
- 过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
### 传统方法学（生命周期方法学，结构化范型）（各自特点，优缺点，背诵）
**特点：**<br />1、把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。<br />2、每一个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。<br />3、在每一个阶段结束之前都必须进行正式严格的技术审查和管理复审<br />4、审查的一条主要标准就是每个阶段都应该交出“最新式的”（即和所开发的软件完全一致的）高质量的文档资料，从而保证在软件开发工程结束时有一个完整准确的软件配置交付使用。<br />**优点：**<br />降低了软件开发工程的困难程度，保证了软件质量，提高了软件的可维护性，大大提高了软件的开发成功率和生产率。
### 面向对象方法学
**特点：**<br />1、把对象（object）作为融合了数据及在数据上的操作行为的统一的软件构件。<br />2、 把所有对象都划分成类（class）。每个类都定义了一组数据和一组操作，类是对具有相同数据和相同操作的一组相似对象的定义。数据用于表示对象的静态属性，是对象的状态信息，而施加于数据之上的操作用于实现对象的动态行为。<br />3、​按照父类（或称为基类）与子类（或称为派生类）的关系，把若干个相关类组成一个层次结构的系统（也称为类等级）。在类等级中，下层派生类自动拥有上层基类中定义的数据和操作，这种现象称为继承。<br />4、对象彼此间仅能通过发送消息互相联系。<br />**优点：**<br />1、降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作。<br />2、面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的可重用性。
## 软件生命周期（8个阶段是什么、任务、特点， 背诵）
​<br />
## 软件过程模型（生命周期模型）
### 瀑布模型
**特点：**1、阶段间具有顺序性和依赖性 2、推迟实现的观点3、质量保证的观点（1）每个阶段都必须完成规定的文档（2）每个阶段结束前完成文档审查，及早改正错误<br />**优缺点：**<br />可强迫开发人员采用规范的方法（例如，结构化技术）；严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。<br />人的认识是一个多次反复循环的过程，不可能一次完成。但瀑布模型中划分的几个阶段，没有反映出这种认识过程的反复性，缺少‘反馈环’。软件开发是一个知识密集型的开发活动，需要相互合作完成，瀑布模型没有体现这一点。“文档驱动”是它的一个主要缺点。在可运行的软件产品交付给用户之前，用户只能通过文档来了解产品，很难全面正确地认识动态的软件产品。由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。<br />**适用范围：**<br />灵活性差，需求简单的项目
### 快速原型模型
**特点：**1、开发者和用户一起定义软件的总体目标2、快速设计可视化界面3、原型由用户评估<br />**优缺点：**<br />不带反馈环。软件产品的开发基本上是线性顺序进行的。迭代成本低，周期短，有快速开发工具。<br />所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。<br />**适用范围：**<br />需求模糊，中小型系统，已有原型且对开发熟悉。
#### 本质
快速原型的本质是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。
#### 能基本上做到线性顺序开发的主要原因
1、原型系统已经通过与用户交互而得到验证，据此产品的规格说明文档开发出错少<br />2、开发人员通过建立原型系统已经学到许多东西，减少了在后阶段需要改正前面阶段犯错的可能性
### 增量模型
**特点：**把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。分解约束条件：当把新构件集成到现有软件中时，所形成的产品必须是可测试的。<br />**优缺点：**<br />1、能在较短时间内向用户提交可完成部分工作的产品<br />2、逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击<br />3、风险小<br />1、在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。<br />2、必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加人新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。<br />**适用范围：**已有产品升级、新版本开发
### 螺旋模型
**特点：**基本思想：使用原型及其他方法来尽量降低风险。每个阶段前都增加了风险分析过程的快速原型模型。也就是 瀑布模型+风险分析+快速原型模型（或 增量模型+风险）。维护只是螺旋模型的另一个周期，在维护和开发之间本质上并没有区别，从而解决了做太多测试或未作足够测试所带来的风险。<br />**优缺点：**<br />可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险；更重要的是，在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。<br />风险驱动是弱点，要求软件开发人员有丰富的专业知识。<br />**适用范围：**内部开发的大规模软件项目
### 喷泉模型
喷泉是面向对象模型，体现了无缝和迭代两个特性
### 最佳实践
1.迭代式开发2.管理需求3.使用基于构件的体系结构4.可视化建模5.验证软件质量6.控制软件变更
### RUP工作阶段
·初始阶段：建立业务模型，定义最终产品视图，并且确定项目的范围。<br />·精化阶段：设计并确定系统的体系结构，制定项目计划，确定资源需求。<br />·构建阶段：开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详<br />尽地测试所有功能<br />·移交阶段：把开发出的产品提交给用户使用
### 敏捷过程4个价值观
敏捷过程为了使软件开发团队具有高效工作和快速响应变化的能力。<br />（1）个体和交互胜过过程和工具<br />（2）可以工作的软件胜过面面俱到的文档<br />（3）客户合作胜过合同谈判<br />（4）响应变化胜过遵循计划
### 微软过程5个阶段（知道）
1、规划阶段     2、设计阶段     3、开发阶段    4、稳定阶段    5、发布阶段<br />​<br />
# 第二章 可行性研究
## 可研3个方面
(1)技术可行性（2）经济可行性（3）操作可行性
## 可研8个过程

1. 复查系统规模和目标
1. 研究目前正在使用的系统
1. 导出新系统的高层逻辑模型

（知道）优秀的设计过程通常是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理统

4. 进一步定义问题
4. 导出和评价供选择的解法
4. 推荐行动方针
4. 草拟开发计划
4. 书写文档提交审查
## 系统流程图
（知道）是描绘物理系统的传统工具。它的基本思想是用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，是物理数据流图而不是程序流程图。<br />符号了解
## 数据流图（DFD）
描绘信息流和数据从输入移动到输出的过程中所经受的变换，数据流图是描绘逻辑结构的。
### 符号
1、正方形（立方体）--数据的源点或终点<br />2、圆角矩形（圆形）--变换数据的处理<br />3、开口矩形（两条平行线）--数据存储<br />4、箭头--数据流
### 画法（由外向里）（知道）
1、确定系统输入输出<br />2、由外向里画系统的顶层数据流图。将输入和输出用一连串加工连接起来<br />3、自顶向下逐层分解，绘出分层数据流图
### 用途（知道）
画数据流图的基本目的是利用它作为交流信息的工具。分析员把他对现有系统的认识或对目标系统的设想用数据流图描绘出来，供有关人员审查确认。<br />数据流图的另一个主要用途是作为分析和设计的工具。
## 数据字典（DD）
数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。
### DFD和DD关系
数据流图和数据字典共同构成系统的逻辑模型，没有数据字典，数据流图就不严格，然而没有数据流图，数据字典也难于发挥作用。
### 用途（知道）
数据字典最重要的用途是作为分析阶段的工具。在数据字典中建立的一组严密一致的定义很有助于改进分析员和用户之间的通信，因此将消除许多可能的误解。对数据的这一系列严密一致的定义也有助于改进在不同的开发人员或不同的开发小组之间的通信。
## 成本估计技术（了解）
1、代码行技术<br />2、任务分解技术<br />3、自动估计成本技术
## 成本/效益分折的方法（了解）
1、货币的时间价值<br />2、投资回收期<br />3、纯收入<br />4、投资回收率
# 第三章 需求分析
## 4个任务
1、确定对系统的综合要求 ①功能需求②性能需求③可靠性和可用性需求④出错处理需求⑤接口需求⑥约束⑦逆向需求⑧将来可能提出的要求<br />2、分析系统的数据要求<br />3、导出系统的逻辑模型<br />4、修正系统开发计划
## 与用户沟通获取需求的方法 
1、访谈<br />2、面向数据流自顶向下求精<br />3、简易的应用规格说明技术<br />4、快速建立软件原型
## 三种模型（知道）
### 数据模型--实体联系图（E-R图）
用途：描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。<br />注意：画ER图时每个联系都加上属性
### 功能模型--数据流图
用途：描绘当数据在软件系统中移动时被变换的逻辑过程，指明系统具有的变换数据的功能，因此，数据流图是建立功能模型的基础。
### 行为模型--状态转换图
用途：指明了作为外部事件结果的系统行为。状态转换图是行为建模的基础。<br />注意：在一张状态图中只能有一个初态，而终态则可以有0至多个。
### Warnier图，IPO图，层次方框图
Warnier图用树形结构描绘数据的层次结构，但是这种图形工具比层次方框图提供了更丰富的描绘手段。<br />IPO描绘输入数据、对数据的处理和输出数据之间的关系。是描绘算法的工具。<br />层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。（和总体设计的层次图进行区分）<br />​<br />
## 从哪些方面验证需求的正确性
1、**一致性 **任何一条需求不能和其他需求互相矛盾。<br />2、**完整性 **规格说明书应该包括用户需要的每一个功能或性能。<br />3、**现实性 **指定的需求是用现有的硬件、软件技术可以实现的。<br />4、**有效性 **需求是正确有效的，确实能解决用户面对的问题。
# 第四章 并发系统中遇到的一个主要问题是定时问题
# 第五章 总体设计
包括系统设计和结构设计
## 步骤

1. 设想供选择的方案
1. 选取合理的方案
1. 推荐最佳方案
1. 功能分解
1. 设计软件结构
1. 设计数据库
1. 制定测试计划
1. 书写文档
1. 审查和复审
## 5条设计原理
1、模块化 <br />把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。<br />2、抽象<br />抽出事物的本质特性而暂时不考虑它们的细节<br />3、逐步求精<br />为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。<br />4、信息隐藏<br />使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不能访问的。<br />5、局部化<br />把一些关系密切的软件元素物理地放得彼此靠近。
## 耦合、内聚

1. **数据耦合：**两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据
1. **控制耦合：**传递的信息中有控制信息（尽管有时这种控制信息以数据的形式出现）
1. **特征耦合：**把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时(传递的数据结构，数组）
1. **公共环境耦合：**当两个或多个模块通过一个公共数据环境相互作用时
1. **内容耦合**：如果出现下列情况之一，两个模块间就发生了内容耦合。#一个模块访问另一个模块的内部数据。#一个模块不通过正常人口而转到另一个模块的内部。#两个模块有一部分程序代码重叠（只可能出现在汇编程序中）。#一个模块有多个人口（这意味着一个模块有几种功能）。

**尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。**

1. **功能内聚：**模块内所有处理元素属于一个整体，完成一个单一的功能
1. **顺序内聚：**如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行（通常一个处理元素的输出数据作为下一个处理元素的输入数据）
1. **通信内聚：**如果模块中所有元素都使用同一个输入数据和（或）产生同一个输出数据
1. **过程内聚：**如果一个模块内的处理元素是相关的，而且必须以特定次序执行
1. **时间内聚：**如果一个模块包含的任务必须在同一段时间内执行（例如，模块完成各种初始化工作）
1. **逻辑内聚：**如果一个模块完成的任务在逻辑上属于相同或相似的一类（例如一个模块产生各种类型的全部输出）
1. **偶然内聚：**如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做偶然内聚。有时在写完一个程序之后，发现一组语句在两处或多处出现，于是把这些语句作为一个模块以节省内存

**1/2 高内聚 3/4中内聚 5/6/7 低内聚  设计做到高内聚、少用中内聚、不用低内聚。**
## 启发式规则
1、改进软件结构提高模块独立性<br />2、模块规模应该适中<br />3、深度宽度、扇出和扇入都应适当①深度表示软件结构中控制的层数②宽度是软件结构内同一个层次上的模块总数的最大值。③扇出是一个模块直接控制（调用）的模块数目④一个模块的扇人表明有多少个上级模块直接调用它<br />4、模块的作用域应该在控制域之内<br />5、力争降低模块接口的复杂程度<br />6、设计单入口单出口的模块<br />7、模块功能应该可以预测
## 层次图和结构图（知道）
层次图用来描绘软件的层次结构。层次图作为描绘软件结构的文档。
### 层次图（第五章）和层次方框图区别：
层次图的一个矩形框代表一个模块，方框间的连线表示调用关系。层次方框图连线表示组成关系。<br />结构图是进行软件结构设计的另一个有力工具。结构图和层次图类似，也是描绘软件结构的图形工具，图中一个方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头（或直线）表示模块的调用关系。尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息。
## 面向数据流的设计方法
### 步骤
1、复查基本系统模型<br />2、复查并精化数据流图<br />3、确定数据流图具有变换特性还是事务特性<br />4、确定数据流的边界（确定输入流和输出流的边界。从而孤立出 变换中心）<br />5、完成“第一级分解”（功能模块图）<br />6、完成“第二级分解”（软件结构图）<br />7、优化<br />面向数据流的设计方法把信息流映射成软件结构，数据流有变换流和事务流。
# 第六章 详细设计
**详细设计的目标：**确定应该怎样具体地实现所要求的系统。<br />结构程序设计技术是实现上述目标的关键技术，因此是详细设计的逻辑基础。<br />详细设计的结果决定代码质量 。<br />**任务：**不是具体地编写程序，而是要设计出程序的 “蓝图”，以后程序员将根据这个“蓝图”写出实际的程序代码。
## 结构程序设计（知道）
3种基本的控制结构—顺序，选择（分支），循环。
### 定义 
经典定义：“如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个人口和一个出口，则称这个程序是结构化的。”<br />全面定义：“结构程序设计是尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句。"
### 人机界面设计4个问题 
1、系统响应时间（两个重要属性，分别是长度和易变性）2、用声帮助设施3、出错信息处理4、命令交互
## 程序流程图（可以任意转移控制）（知道）
优点：对控制流程的描绘很直观，便于初学者掌握。<br />缺点：<br />（1）程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。<br />（2）程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。<br />（3）程序流程图不易表示数据结构。
## 盒图（不能任意转移控制）（知道）
特点：<br />1、功能域（即一个特定控制结构的作用域）明确，可以从盒图上一眼就看出来。<br />2、不可能任意转移控制。<br />3、很容易确定局部和全程数据的作用域<br />4、很容易表现嵌套关系，也可以表示模块的层次结构。
## PAD图（问题分析图）
优点：<br />1、设计出来的程序必然是结构化程序。<br />2、描绘的程序结构十分清晰。<br />3、表现程序逻辑，易读、易懂、易记。<br />4、容易将PAD图转换成高级语言源程序。<br />5、可用于表示程序逻辑，也可用于描绘数据结构。<br />6、PAD图的符号支持自顶向下、逐步求精方法的使用。
## 过程设计语言（PDL）（了解）
PDL是伪码<br />优点：<br />1、可以作为注释直接插在源程序中间。<br />2、可以使用普通的正文编辑程序或文字处理系统。<br />3、已经有自动处理PDL的程序存在，而且可以自动由PDL生成程序代码。<br />缺点：不如图形工具形象直观。
## 面向数据结构的设计方法
面向数据流的设计方法--根据数据流确定软件结构的方法。<br />面向数据结构的设计方法--根据数据结构设计程序处理过程的方法。
## Jackon图（了解）
优点：1、便于表示层次结构，而且是对结构进行自顶向下分解的有力工具2、形象直观可读性好。<br />3、既能表示数据结构也能表示程序结构（因为结构程序设计也只使用上述3种基本控制结构）。
### Jackon图与层次图区别
1、层次图中的一个方框通常代表一个模块；而Jackson图即使在描绘程序结构时，一个方框也并不代表一个模块，通常一个方框只代表几个语句。<br />2、层次图表现的是调用关系，Jackson图表现的是组成关系
## 程序复杂程度的定量度量
### McCabe方法（知道）
McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。流图实质上是“退化了的"程序流程图。
### 计算环形复杂度的方法
1、流图中线性无关的区域数等于环形复杂度。<br />2、流图G的环形复杂度v（G) = E- N + 2，其中，E是流图中边的条数，N是结点数。<br />3、流图G的环形复杂度v（G) = P + 1，其中，P是流图中判定结点的数目。
# 第七章 实现
## 效率（知道）
定义：效率主要指处理机时间和存储器容量两个方面。<br />3条原则：1、效率是性能要求，因此应该在需求分析阶段确定效率方面的要求。2、效率是靠好设计来提高的。3、程序的效率和程序的简单程度是一致的，不要牺牲程序的清晰性和可读性来不必要地提高效率。
## 测试
定义或目的：1、测试是为了发现程序中的错误而执行程序的过程。<br />2、好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。<br />3、 成功的测试是发现了至今为止尚未发现的错误的测试。
## 软件测试准则 
1、所有测试都应该能追溯到用户需求。<br />2、应该远在测试开始之前就制定出测试计划。<br />3、把Pareto原理应用到软件测试中。<br />4、应该从“小规模”测试开始，并逐步进行“大规模”测试。<br />5、穷举测试是不可能的。<br />6、为了达到最佳的测试效果，应该由独立的第三方从事测试工作。
## 黑盒、白盒测试（知道）
白盒写出各种覆盖的测试用例，其中的控制结构测试能写出线性独立路径的基本集合（ P167 ）课后题有练习 。<br />黑盒测试（功能测试）：如果已经知道了产品应该具有的功能，可以通过测试来检验是否每个功能都能正常使用。<br />技术：1、等价划2、边界值分析3、错误推测4、因果图（资料P53）<br />白盒测试（结构测试）：如果知道产品的内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常进行。<br />技术：逻辑测试1、语句覆盖2、判定覆盖3、条件覆盖4、判定/条件覆盖5、条件组合覆盖6、点覆盖7、边覆盖8、路径覆盖<br />二者都是动态测试。
## 软件测试步骤（知道）
1，模块测试<br />2、子系统测试<br />3、系统测试<br />4、验收测试<br />5、平行运行
## 单元测试
特点：单元测试主要使用白盒测试技术，而且对多个模块的测试可以并行地进行。<br />测试重点：1、模块接口2、局部数据结构3、重要的执行通路4、出错处理通路5、边界条件
## 集成测试
自顶向下和自底向上的比较：<br />自顶向下测试优点：不需要测试驱动程序，能够在测试阶段早期实现并验证系统的主要功能，能够在早期发现上层模块的接口错误。<br />自顶向下测试缺点：需要存根程序，低层关键模块中的错误发现较晚，而且用这种方法早期不能充分展开人力。<br />自底向上的优缺点与上述相反。<br />存根程序：从要测试的软件组件中调用存根。
## 确认测试（知道）
使用黑盒测试技术，发现需求分析阶段的错误。<br />验证指的是保证软件正确地实现了某个特定要求的一系列活动，而确认指的是为了保证软件确实满足了用户需求而进行的一系列活动。<br />Alpha测试（受控）和Beta测试（不受控）
## 回归测试（知道）
回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。<br />回归测试就是用于保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额外错误的测试活动。
## 调试途径 （知道）
1、蛮干法2、回溯法3、原因排除法 
# 第八章 维护（知道）
## 四种维护
1、改正性维护（17%~21%)<br />2、适应性维护（18%~25%）<br />3、完善性维护（50%~66%）<br />4、预防性维护（不到5%）
## 决定软件可维护性的因素 
1、可理解性2、可测试性3、可修改性4、可移植性5、可重用性<br />文档是影响软件可维护性的决定因素。
## 结构化维护与非结构化维护本质区别：是否有完整的软件配置
## 软件再工程过程模型 
1、库存目录分析2、文档重构3、逆向工程4、代码重构5、数据重构6、正向工程
# 第九章 面向对象方法学引论
## 面向对象方法学（知道）
### 出发点和基本原则
尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程，也就是使描述问题的问题空间（也称为问题域）与实现解法的解空间（也称为求解域）在结构上尽可能一致。
### 4个要点
1、认为客观世界是由各种对象组成的，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成。<br />2、把所有对象都划分成各种对象类（简称为类，class），每个对象类都定义了一组数据和一组方法。数据用于表示对象的静态属性，是对象的状态信息。<br />3、按照子类（或称为派生类）与父类（或称为基类）的关系，把若干个对象类组成一个层次结构的系统（也称为类等级）。<br />4、对象彼此之间仅能通过传递消息互相联系。
### 优点
1、与人类习惯的思维方法一致<br />2、稳定性好<br />3、可重用性好<br />4、较易开发大型软件产品<br />5、可维护性好
## 相关概念
### 对象
面向对象方法学中的对象是由描述该对象属性的数据以及可以对这些数据施加的所有操作封装在一起构成的统一体。对象可以作的操作表示它的动态行为，在面向对象分析和面向对象设计中，通常把对象的操作称为服务或方法。<br />特点：1、以数据为中心2、对象是主动的，它是进行处理的主体3、实现了数据封装4、本质上具有并行性5、模块独立性好
### 类
在面向对象的软件技术中，“类”就是对具有相同数据和相同操作的一组相似对象的定义，也就是说，类是对具有相同属性和行为的一个或多个对象的描述，通常在这种描述中也包括对怎样创建该类的新对象的说明。
### 实例（instance）
1、实例就是由某个特定的类所描述的一个具体的对象。<br />2、“对象”这个术语时，既可以指一个具体的对象，也可以泛指一般的对象，但是，当使用“实例”这个术语时，必然是指一个具体的对象。
### 消息（message）
消息就是要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明。通常，一个消息由下述3部分组成。<br />1、接收消息的对象。<br />2、消息选择符（也称为消息名）。<br />3、零个或多个变元。
### 方法（method）
方法就是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法。
### 属性（attribute）
属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽象。类的每个实例都有自己特有的属性值。
### 封装（encapsulation）
在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。<br />对象具有封装性的条件如下：<br />1、有一个清晰的边界。<br />2、有确定的接口（即协议）。<br />3、受保护的内部实现。
### 继承(inheritance)
在面向对象的软件技术中，继承是子类自动地共享基类中定义的数据和方法的机制。
### 多态性(polymorphism)
在面向对象的软件技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。
### 重载(overloading)
有两种重载：函数重载是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字；运算符重载是指同一个运算符可以施加于不同类型的操作数上面。
## 面向对象建模
对象模型--描述系统数据结构--类图（知道画法 P217）<br />动态模型--描述系统控制结构--状态转换图<br />功能模型--描述系统功能--用例图（知道画法  P225）<br />用例图组成部分4点：1、系统2、用例3、行为者（不单单指人）4、用例之间的关系：使用、拓展<br />​<br />
## 类与类之间的关系（知道）
1、关联 （知道画法）<br />2、聚集--类与类之间的关系是整体与部分的关系（知道共享聚集，组合聚集画法 P220）<br />3、泛化（继承）--类与类之间存在“一般-特殊”关系（知道画法）<br />4、依赖和细化
## 扩展关系和使用关系（知道）
向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用例。<br />当一个用例使用另一个用例时，这两个用例之间就构成了使用关系。<br />异同：通常在描述一般行为的变化时采用扩展关系；在两个或多个用例中出现重复描述又想避免这种重复时，可以采用使用关系。
## 3种模型之间的关系

1. 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。
1. 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应。
1. 功能模型中的处理（或用例）对应于对象模型中的类所提供的服务。通常，复杂的处理（或用例）对应于复杂对象提供的服务，简单的处理（或用例）对应于更基本的对象提供的服务。有时一个处理（或用例）对应多个服务，也有一个服务对应多个处理（或用例）的时候。
1. 数据流图中的数据存储，以及数据的源点／终点，通常是对象模型中的对象。
1. ​数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。
1. ​用例图中的行为者，可能是对象模型中的对象。
1. 功能模型中的处理（或用例）可能产生动态模型中的事件。
1. 对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。
# 第十、十一、十二章  面向对象分析、设计、实现
## 3个模型5个层次
1、静态结构（对象模型）2、交互次序（动态模型）3、数据变换（功能模型）<br />1、主题层 2、类与对象层 3、结构层 4、属性层 5、服务层
## 建立继承关系的方式 （知道）
1、自底向上：抽象出现有类的共同性质泛化出父类，这个过程实质上模拟了人类归纳思维过程。<br />2、自顶向下：把现有类细化成更具体的子类，这模拟了人类的演绎思维过程。从应用域中常常能明显看出应该做的自顶向下的具体化工作。
## 面向对象设计准则
1、模块化2、抽象3、信息隐藏4、弱耦合 ①交互耦合 应该松散 ②集成耦合 应该紧密5、强内聚6、可重用
## 启发式规则
1、设计结果应该清晰易懂<br />2、一般·特殊结构的深度应适当<br />3、设计简单的类<br />4、使用简单的协议<br />5、使用简单的服务<br />6、把设计变动减至最小
## 软件重用
### 三个层次
1、知识重用（例如软件工程知识的重用）<br />2、方法和标准的重用（例如，面向对象方法或国家制定的软件开发规范的重用）。<br />3、软件成分的重用
### 类构件的三种重用方式
1、实例重用<br />2、继承重用<br />3、多态重用<br />实例重用是最基本的。
### 可重用构件的特点（知道）
1、模块独立性强。<br />2、具有高度可塑性。<br />3、接口清晰、简明、可靠。
## 系统分解
### 面向对象设计阶段4个子系统
1、问题域子系统<br />2、人机交互子系统<br />3、任务管理子系统<br />4、数据管理子系统
### 子系统之间的两种交互方式
1、客户-供应商关系<br />2、平等伙伴关系
### 组织系统的两种方案
1、层次组织<br />2、块状组织
## 测试策略
### 集成测试的两种策略
1、基于线程的测试<br />2、基于使用的测试
### 测试类的方法
1、随机测试<br />2、划分测试<br />3、基于故障的测试
### 集成测试的方法
1、多类测试<br />2、从动态模型导出测试用例
### 确认测试的方法
根据动态模型和描述系统行为的脚本来设计确认测试用例。
# 第十三章 软件项目管理
软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命周期之中。<br />软件项目管理过程从一组项目计划活动开始，而制定计划的基础是工作量估算和完成期限估算。为了估算项目的工作量和完成期限，首先需要估算软件的规模。
## 估算软件规模的方法
1、代码行技术<br />2、功能点技术--5个信息域特性--(1)输入项数(2)输出项数(3)查询数(4)主文件数(5)外部接口数
## 工作量估算模型（知道）
1、静态单变量模型<br />2、动态多变量模型<br />3、COCOMO2模型
## 估计开发时间（知道）
1、Walston Felix模型<br />2、原始的COCOMO模型<br />3、COCOM02模型<br />4、 Putnam模型
## 进度计划
都是制定进度计划的工具
### 甘特图（Gantt）（知道）
Gantt（甘特）图是历史悠久、应用广泛的制定进度计划的工具<br />优点：1、很形象地描绘任务分解情况，以及每个子任务（作业）的开始时间和结束时间。<br />2、直观简明和容易掌握、容易绘制。<br />缺点：1、不能显式地描绘各项作业彼此间的依赖关系。<br />2、进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象。<br />3、计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费。
### 工程网络图（知道）（可能会考画法）
工程网络是制定进度计划时另一种常用的图形工具，它同样能描绘任务分解情况以及每项作业的开始时间和结束时间，此外，它还显式地描绘各个作业彼此间的依赖关系。
## 人员组织方式 （知道）
1、民主制程序员组<br />2、主程序员组<br />3、现代程序员组
## 软件质量
软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。
### 影响软件质量的主要因素（记住特性即可）
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1173812/1633683352960-a7316972-0145-460d-95d5-68867597d829.png#clientId=uaccb5e72-f53b-4&from=paste&height=433&id=ub3d2e261&margin=%5Bobject%20Object%5D&name=image.png&originHeight=433&originWidth=883&originalType=binary&ratio=1&size=160750&status=done&style=none&taskId=u92a39762-78ff-4113-a559-84a0e3399cc&width=883)
### 软件质量保证措施3条
1、基于非执行的测试（也称为复审或评审）--主要用来保证在编码之前各阶段产生的文档的质量<br />2、基于执行的测试（即以前讲过的软件测试）--需要在程序编写出来之后进行，它是保证软件质量的最后一道防线<br />3、程序正确性证明--使用数学方法严格验证程序是否与对它的说明完全一致。
### 基线（知道）
基线是一个软件配置管理概念，基线就是通过了正式复审的软件配置项。在软件配置项变成基线之前，可以迅速而非正式地修改它。一旦建立了基线之后，虽然仍然可以实现变化，但是，必须应用特定的、正式的过程（称为规程）来评估、实现和验证每个变化。
## 能力成熟度模型CMM
是用于评价软件机构的软件过程能力成熟度的模型。
### 基本思想
由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的运用并不会自动提高软件的生产率和质量。
### 5个等级
1、初始级（又称为1级）<br />过程能力是不可预测的，其软件过程是不稳定的，产品质量只能根据相关人员的个人工作能力而不是 机构的过程能力来预测。<br />2、可重复级（又称为2 级）<br />软件项目的策划和跟踪是稳定的，已经为一个有纪律的管理过程提供了可重复以前成功实践的项目环境。<br />3、已定义级（又称为3级）<br />无论是管理活动还是工程活动都是稳定的。软件开发的成本和进度以及产品的功能和质量都受到控制，而且软件产品的质量具有可追溯性。<br />4、已管理级（又称为4级）<br />软件机构对软件过程（过程模型和过程实例）和软件产品都建立了定量的质量目标，所有项目的重要的过程活动都是可度量的。该软件机构收集了过程度量和产品度量的方法并加以运用<br />5、优化级（又称为5级）<br />软件过程是可优化的。这一级的软件机构能够持续不断地改进其过程能力，既对现行的过程实例不断地改进和优化，又借助于所采用的新技术和新方法来实现未来的过程改进。<br />

